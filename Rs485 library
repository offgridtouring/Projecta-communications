import struct

class ProjectaMasterLibrary:
    def __init__(self):
        self.state = {
            # Telemetry
            'battery_v': 0.0, 'battery_a': 0.0, 'soc': 0,
            'temp_batt': 0.0, 'temp_ext': 0.0,
            'tank_1': 0, 'tank_2': 0,
            'solar_v': 0.0, 'solar_a': 0.0,

            # Switch States (Zeta Module)
            'master_switch': False,   # Output 2-14
            'hot_water': False,       # Output 10
            'water_pump': False,      # Output 11
            'slide_out': False,       # Output 13
            'awning': False           # Output 12
        }

    def process(self, packet_hex):
        p = bytes.fromhex(packet_hex.replace(" ", ""))
        length = len(p)

        # 1. Full Telemetry Snapshot (94 bytes)
        if length == 94 or length == 102:
            d = p[8:] if length == 102 else p
            self.state['battery_v'] = self._i16(d, 20) / 100.0
            self.state['battery_a'] = self._i16(d, 22) / 100.0
            self.state['soc']       = d[25]
            self.state['temp_batt'] = self._i16(d, 28) / 10.0
            self.state['temp_ext']  = self._i16(d, 50) / 10.0
            self.state['tank_1']    = d[41]
            self.state['tank_2']    = d[43]
            self.state['solar_v']   = self._i16(d, 4) / 100.0
            self.state['solar_a']   = self._i16(d, 6) / 100.0

        # 2. Switching Logic (20 bytes)
        elif length == 20:
            reg = int.from_bytes(p[2:4], 'big')
            val = int.from_bytes(p[6:8], 'big')
            status = (val > 0)

            # Map based on observed registers for your 5 outputs
            if reg == 0x011D: self.state['master_switch'] = status
            elif reg == 0x011E: self.state['water_pump'] = status
            # Add other registers as you sniff them during physical button presses
            
        return self.state

    @staticmethod
    def _i16(p, offset):
        return int.from_bytes(p[offset:offset+2], 'big', signed=True)
